'Endereco padrao
CONST DXM_LocalReg	= 199

'MODBUSTYPE para cada porta
CONST Port_0 = 0
CONST Port_1 = 256
CONST Port_2 = 512
CONST Port_3 = 768
CONST Port_4 = 1024

'SLAVE IDs somado do offset para porta
CONST MB_Broadcast	= 0
CONST HUB1 = 20
CONST HUB2 = 21
CONST HUB3 = 22
CONST HUB4 = 23
CONST HUB5 = 24
CONST HUB6 = 25
CONST HUB7 = 26
CONST HUB8 = 27


'Registradores Locais

CONST TempoReg = 300
CONST TempoRegPulso = 310
CONST Diferenca = 320
CONST TempoDeCiclo = 1
CONST Contador = 2
CONST activeConnections = 12
CONST Emergency_4063 = 20
CONST Ready_4063 = 23
CONST Word_Status_4063 = 27

' --- Status da Maquina ---
' Constantes para os valores de cada bit de status (potencias de 2)
CONST Status_Bit_PlannedDownTime_Val = 1   ' Bit0: 2^0
CONST Status_Bit_Running_Val         = 2   ' Bit1: 2^1
CONST Status_Bit_Starving_Val        = 4   ' Bit2: 2^2
CONST Status_Bit_Blocked_Val         = 8   ' Bit3: 2^3
CONST Status_Bit_Ready_Val           = 16  ' Bit4: 2^4
CONST Status_Bit_Falha_Val           = 32  ' Bit5: 2^5
CONST Status_Bit_Setup_Val           = 64  ' Bit6: 2^6
CONST Status_Bit_Emergencia_Val      = 128 ' Bit7: 2^7

'Registrador do HUB
CONST P2_Active_State = 1002
CONST P2_Counter = 1012
CONST P4_Counter = 1004

'Variaveis internas
TemponovoPulso1 = 0
TemponovoPulso2 = 0
TemponovoPulso3 = 0
TemponovoPulso4 = 0
TemponovoPulso5 = 0
TemponovoPulso6 = 0
TemponovoPulso7 = 0
TemponovoPulso8 = 0
i0 = 0
i1 = 0
i2 = 0
i3 = 0
i4 = 0
i5 = 0
i6 = 0
i7 = 0
i8 = 0
active1 = 0
active2 = 0
active3 = 0
active4 = 0
active5 = 0
active6 = 0
active7 = 0
active8 = 0

' Variaveis para o estado atual da maquina (0 para Inativo, 1 para Ativo)
' Estas variaveis devem ser atualizadas pela logica especifica da sua maquina.
Cond_PlannedDownTime = 0
Cond_Running = 0
Cond_Starving = 0
Cond_Blocked = 0
Cond_Ready = 0
Cond_Falha = 0
Cond_Setup = 0
Cond_Emergencia = 0

' Variavel para armazenar o status da maquina como inteiro
MachineStatusINT = 0

FUNCTION ResetTimer(TReg)
    Err = SETREG(TReg, 0, DXM_LocalReg, HoldingReg)
END FUNCTION

FUNCTION ResetTimerPulso(TRegPulso)
    Err = SETREG(TRegPulso, 0, DXM_LocalReg, HoldingReg)
END FUNCTION

FUNCTION GeraPulsoHUB1
LOCAL TempoPulso1, Diff1
TempoPulso1 = GETREG(HUB1+TempoRegPulso+1-20, DXM_LocalReg, HoldingReg)
Diff1 = TempoPulso1 - TemponovoPulso1
Err = SETREG(HUB1+Diferenca+1-20, Diff1, DXM_LocalReg, HoldingReg)
    IF Diff1 >= 3 THEN
        'active = NOT active
        active1 = 1
        Err = SETREG(((HUB1*16)+12-320), active1, DXM_LocalReg, HoldingReg)
        TemponovoPulso1 = TempoPulso1
    ELSE
        active1 = 0
        Err = SETREG(((HUB1*16)+12-320), active1, DXM_LocalReg, HoldingReg)
    END IF    
END FUNCTION

FUNCTION GeraPulsoHUB2
LOCAL TempoPulso2, Diff2
'Busco o tempo do registrador local TempoRegPulso (310)
TempoPulso2 = GETREG(HUB2+TempoRegPulso+1-20, DXM_LocalReg, HoldingReg)
'Calcula diferenca de tempo 
Diff2 = TempoPulso2 - TemponovoPulso2
'Escrevo o resultado da diferenca no registrador local Diferenca(320)
Err = SETREG(HUB2+Diferenca+1-20, Diff2, DXM_LocalReg, HoldingReg)
'Condicao de: Se a diferenca for maior que 3, active vai para um, enquanto nao for maior, fica em 0
    IF Diff2 >= 3 THEN
        'active = NOT active
        active2 = 1
        Err = SETREG(((HUB2*16)+12-320), active2, DXM_LocalReg, HoldingReg)
        TemponovoPulso2 = TempoPulso2
    ELSE
        active2 = 0
        Err = SETREG(((HUB2*16)+12-320), active2, DXM_LocalReg, HoldingReg)
    END IF    
END FUNCTION

FUNCTION TempoDeCicloEContagemHUB1
LOCAL Tempo1, Temponovo1
'Leitura do registrador de contagem do HUB (Pino 2 da Porta 1 do R95C)
Count1 = GETREG(P4_Counter, HUB1, Port_4)
'print "Contador: ", Count, "\n"
Tempo1 = GETREG(HUB1+TempoReg+1-20, DXM_LocalReg, HoldingReg)
'print "Tempo: ", Tempo, "\n"
'Comparo o contador interno com o contador do HUB, se for diferente, entra na condicao.
IF Count1 <> Counter1 THEN
    'Somo a variavel de contagem
    i0=i0+1
    'Escrevo a variavel de contagem no registrador local "Contador" '
    Err = SETREG(((HUB1*16)+2-320),i0,DXM_LocalReg,HoldingReg)
    'ContagemAntiga = Contagem 
    Temponovo1 = Tempo1
    print "Tempo de ciclo HUB 1: ", Temponovo1, "\n"
    'Escrevo a variavel de contagem no registrador local "TempoDeCiclo" '
    Err = SETREG(((HUB1*16)+1-320), Temponovo1, DXM_LocalReg, HoldingReg)
    'Reseto o tempo do registrador local para iniciar a contagem de um novo ciclo
    ResetTimer(HUB1+TempoReg+1-20)
    Counter1 = Count1
    print "Contador HUB 1: ", Counter1, "\n"
END IF
'Caso o valor de contagem atinja 9999, o contador e zerado
IF i0 = 9999 THEN
    i0 = 0
END IF
END FUNCTION

FUNCTION TempoDeCicloEContagemHUB2
LOCAL Tempo2, Temponovo2
'Leitura do registrador de contagem do HUB (Pino 2 da Porta 1 do R95C)
Count2 = GETREG(P4_Counter, HUB2, Port_4)
'print "Contador: ", Count, "\n"
Tempo2 = GETREG(HUB2+TempoReg+1-20, DXM_LocalReg, HoldingReg)
'print "Tempo: ", Tempo, "\n"
'Comparo o contador interno com o contador do HUB, se for diferente, entra na condicao.
IF Count2 <> Counter2 THEN
    'Somo a variavel de contagem
    i1=i1+1
    'Escrevo a variavel de contagem no registrador local "Contador" '
    Err = SETREG(((HUB2*16)+2-320),i1,DXM_LocalReg,HoldingReg)
    'ContagemAntiga = Contagem 
    Temponovo2 = Tempo2
    print "Tempo de ciclo HUB 2: ", Temponovo2, "\n"
    'Escrevo a variavel de contagem no registrador local "TempoDeCiclo" '
    Err = SETREG(((HUB2*16)+1-320), Temponovo2, DXM_LocalReg, HoldingReg)
    'Reseto o tempo do registrador local para iniciar a contagem de um novo ciclo
    ResetTimer(HUB2+TempoReg+1-20)
    Counter2 = Count2
    print "Contador HUB 2: ", Counter2, "\n"
END IF
'Caso o valor de contagem atinja 9999, o contador e zerado
IF i1 = 999 THEN
    i1 = 0
END IF
END FUNCTION

' --- Funcao para Calcular o Status da Maquina ---
FUNCTION CalcularEMostrarStatusMaquina()
    LOCAL currentStatusINT
    currentStatusINT = 0

    IF Cond_PlannedDownTime = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_PlannedDownTime_Val
    IF Cond_Running = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Running_Val
    IF Cond_Starving = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Starving_Val
    IF Cond_Blocked = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Blocked_Val
    IF Cond_Ready = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Ready_Val
    IF Cond_Falha = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Falha_Val
    IF Cond_Setup = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Setup_Val
    IF Cond_Emergencia = 1 THEN currentStatusINT = currentStatusINT + Status_Bit_Emergencia_Val
    
    MachineStatusINT = currentStatusINT ' Atualiza a variavel global
    Err = SETREG(Word_Status_4063, MachineStatusINT, DXM_LocalReg, HoldingReg) ' Salva no registrador local
END FUNCTION

'WHILE DE EXECUCAO DO SCRIPT
While(1)
    
    'Chamo a funcao de tempo de ciclo e contagem a cada ciclo do while
    TempoDeCicloEContagemHUB1
    TempoDeCicloEContagemHUB2
    'Chamo a funcao de gerar pulso
    GeraPulsoHUB1
    GeraPulsoHUB2

    ' --- Logica de Atualizacao e Calculo do Status da Maquina ---
    ' Exemplo: Definir algumas condicoes (substitua pela logica real da sua maquina)
    ' Para testar o exemplo "Ready e Running (18)":
    Cond_PlannedDownTime = 0
    Cond_Running = 0 
    Cond_Starving = 0
    Cond_Blocked = 0
    Cond_Ready = 0
    IF Ready_4063 = 1 THEN Cond_Ready = 1 ELSE Cond_Ready = 0
    Cond_Falha = 0
    Cond_Setup = 0
    IF Emergency_4063 = 1 THEN Cond_Emergencia = 1 ELSE Cond_Emergencia = 0    
    CalcularEMostrarStatusMaquina

Wend
